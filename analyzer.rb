#!/usr/bin/env ruby
$lexeme = Array.new()
def nextToken()
 	$lexeme.last
end

 	def popToken()
 		$lexeme.pop
 	end	

 	def evaluateNextToken(condition)
		#nextToken =~ /#{condition}/ ? true : false
		if nextToken() =~ /#{condition}/
			temp = popToken()
			puts "\t\t\t\t\t{temp} == #{condition} : TRUE"
			return true 
		else
			#puts "#{nextToken()} == #{condition} : FALSE"
			return false
		end
	end

	#	generated by the rule:   <expr> → <term> {( + | - ) <term>}
	def expr()
		puts "\tEnter<expr>"
		term()
		while (evaluateNextToken("ADD|SUBTRACT")) do
			 term()
		end
		puts "\tExit<expr>"
	end

	# 	   generated by the rule: <term> → <factor> {( * | / ) <factor> }
	def term() 
		puts "\t\tEnter<term>"
		factor()
		while (evaluateNextToken("MULTIPLY|DIVIDE")) do 
			factor()
		end
		puts "\t\tExit<term>"
	end

	def error(error)
		puts "#{error}"
	end

	# <factor> -> id  |  (<expr>)
	def factor() 
		puts "\t\t\tEnter<factor>"
		if evaluateNextToken("IDENTIFIER")
			
		elsif evaluateNextToken("OPENPAREN")
			expr()
			if evaluateNextToken("CLOSEPAREN") 
				
			else
				error("Missing Close Parenthesis")	
			end
		else
			error("Right Hand Side Doesn't Match") #Right Hand Side Doesn't Match
		end
		puts "\t\t\tExit<factor>"
	end

def parseFile()
	#local_filename = "" #lexeme file
	#lexeme = []
	#File.open(local_filename, 'w') {|f| f.write(doc) }
	#open('a.txt').each do |line|
  	#results << line.split('\n')

  	array_in_line = Array.new

  	array_in_line = ["IDENTIFIER", "ASSIGNOP", "IDENTIFIER", "ADD", "IDENTIFIER"]
  	evaluate_line(array_in_line)


  	# this = this * (this / that)
  	array_in_line_with_division = ["IDENTIFIER", "ASSIGNOP", "IDENTIFIER","MULTIPLY","OPENPAREN",
  								   "IDENTIFIER", "DIVIDE", "IDENTIFIER","CLOSEPAREN" ,"TERMINAL"]
  	evaluate_line(array_in_line_with_division)
 	#end
 end



 def evaluate_line(array_in_line)
 	$lexeme = Array.new
 	$lexeme = array_in_line.reverse!
 	puts "Evaluating The Line"

 	$lexeme.pop
 	$lexeme.pop
 	puts $lexeme.join(" ")
 	expr()


 	
	end
	parseFile()