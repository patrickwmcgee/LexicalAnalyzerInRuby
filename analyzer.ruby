
# Variables

/* Function factor
   Parses strings in the language
   generated by the rule: 
   <factor> -> id  |  (<expr>)  
*/

charClass = 0
char lexeme = []
LETTER = 0
DIGIT = 1
UNKNOWN = -1;

def factor 
	if (nextToken =~ /ID_CODE/)
		lex()
	elsif (nextToken =~ /LEFT_PAREN_CODE/)
		lex()
		expr()
		if(nextToken =~ /RIGHT_PAREN_CODE/)
			lex()
		else
			error()
		end
	else
		error()
	end
end

def getNextCharClass() 
	# /*get character from input a
	#   and put in nextChar(not shown…)*/
	character = nextChar()
	if (isDigit(character)) # [a-zA-Z] is the regex to check for 
		charClass = LETTER
	elsif (isDigit(character))
		charClass = DIGIT
	else 
		charClass = UNKNOWN
	end
	charClass
end

def isDigit(variable)
	variable =~ /\d/ ? true : false
end

def isChar(variable)
	variable =~ /([a-zA-z]|[-])/ ? true : false
end

def addChar()
	lexeme.size() <= 99 ? lexeme << nextChar : puts "Error lexeme too long \n"
end

def error()
	puts "Parsing Has failed"
end
def nextChar()
	# gets in next char
end	

def getNonBlank
	while(nextChar =)
end

def nextChar(input_stream,condition))
	#get the next character
	character = a.peek
	condition = 'none'
		#check to see if character satisfies conditions
	case character
     	when LETTER
     		chaddChar()
     		getChar() 
     		while(charClass =~ /LETTER|DIGIT/) do 
     			addChar();
     			getChar();
     		end
     		return lookup(lexeme);
		# Integer literals
		when DIGIT
			addChar();
			getChar();
			while (charClass == DIGIT) {
				addChar()
				getChar()
			}
			return INT_LIT

	end # /* End of switch */
	#if the character satisfies continue

	# add value into lexeme return the token of the lexeme 


	addChar()
	get

end



def getNonBlank(nextChar)
	if (nextChar=~ /\S/)
		return nextChar
	else
		return getNonBlank(nextChar)
	end
end


  def lookup(source)
  	return 
  end

 # /* called by the Parser */
 # /* returns the next token*/
 # Gets the next token out of the stream, uses 

 def nextChar(inputStream, count)
 	stream



 end
  def nextToken() 
  	lexLen = 0;
  	first = true
  	character = ''
  	if first
  		character = getChar()
  		first = false
  	end
  	character = getNonBlank();
  	def to_lex()

  	end
     # Reserved word or Identifier
     case character
     	when LETTER
     		chaddChar()
     		getChar() 
     		while(charClass =~ /LETTER|DIGIT/) do 
     			addChar();
     			getChar();
     		end
     		return lookup(lexeme);
		# Integer literals
		when DIGIT
			addChar();
			getChar();
			while (charClass == DIGIT) {
				addChar()
				getChar()
			}
			return INT_LIT

	end # /* End of switch */
end # /* End of function lex */
#	/* Function expr parses strings in the language
#	generated by the rule:   <expr> → <term> {( + | - ) <term>}
#	*/

def expr()
    term()
	while (nextToken =~/PLUS_CODE|MINUS_CODE/) do
		lex()
		term()
	end
end

=begin
/* Function term
   Parses strings in the language
   generated by the rule: <term> → <factor> {( * | / ) <factor> }
 */
=end
def term() 
  	factor()
	while (nextToken =~ /MULT_CODE|DIV_CODE/) do 
		lex()
		factor()
	end
end



end
/* Function factor
   Parses strings in the language
   generated by the rule: 
   <factor> -> id  |  (<expr>)  
*/

 void factor() {
   if (nextToken) == ID_CODE)
      lex();  	# Get the next token…

   else if (nextToken == LEFT_PAREN_CODE) { 		
      lex();   # Get the next token…
      expr(); 	# expect expression
      if (nextToken == RIGHT_PAREN_CODE)	
	 lex();
      else        		
	 error();
   }  /* End of else if (nextToken == ...  */

   else 
      error(); /* Neither RHS matches */ 
}

 